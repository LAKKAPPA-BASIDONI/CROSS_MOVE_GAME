{"ast":null,"code":"export function getBestMove(state, player) {\n  for (let row = 0; row < 3; row++) {\n    for (let col = 0; col < 3; col++) {\n      if (!state[row][col]) {\n        return {\n          row,\n          col\n        };\n      }\n    }\n  }\n  return null;\n}\nexport function getBestMoveToMove(state, player) {\n  // Implementing Minimax algorithm here for stronger AI\n  let bestMove = null;\n  let bestScore = -Infinity;\n  for (let row = 0; row < 3; row++) {\n    for (let col = 0; col < 3; col++) {\n      if (state[row][col] === AI) {\n        const adjacent = getAdjacentCells(row, col);\n        for (const [r, c] of adjacent) {\n          if (!state[r][c]) {\n            const tempState = state.map(arr => arr.slice());\n            tempState[r][c] = AI;\n            tempState[row][col] = null;\n            const score = minimax(tempState, 0, false);\n            if (score > bestScore) {\n              bestScore = score;\n              bestMove = {\n                from: {\n                  row,\n                  col\n                },\n                to: {\n                  row: r,\n                  col: c\n                }\n              };\n            }\n          }\n        }\n      }\n    }\n  }\n  return bestMove;\n}\nfunction minimax(state, depth, isMaximizing) {\n  const winner = checkWinner(state);\n  if (winner === AI) return 10 - depth;\n  if (winner === PLAYER) return depth - 10;\n  if (isBoardFull(state)) return 0;\n  let bestScore = isMaximizing ? -Infinity : Infinity;\n  for (let row = 0; row < 3; row++) {\n    for (let col = 0; col < 3; col++) {\n      if (!state[row][col]) {\n        state[row][col] = isMaximizing ? AI : PLAYER;\n        const score = minimax(state, depth + 1, !isMaximizing);\n        state[row][col] = null;\n        bestScore = isMaximizing ? Math.max(score, bestScore) : Math.min(score, bestScore);\n      }\n    }\n  }\n  return bestScore;\n}\nfunction isBoardFull(state) {\n  return state.every(row => row.every(cell => cell));\n}","map":{"version":3,"names":["getBestMove","state","player","row","col","getBestMoveToMove","bestMove","bestScore","Infinity","AI","adjacent","getAdjacentCells","r","c","tempState","map","arr","slice","score","minimax","from","to","depth","isMaximizing","winner","checkWinner","PLAYER","isBoardFull","Math","max","min","every","cell"],"sources":["E:/Games/CrossMove/frontend - Copy/src/components/checking.js"],"sourcesContent":["export function getBestMove(state, player) {\r\n    for (let row = 0; row < 3; row++) {\r\n        for (let col = 0; col < 3; col++) {\r\n            if (!state[row][col]) {\r\n                return { row, col };\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\nexport function getBestMoveToMove(state, player) {\r\n    // Implementing Minimax algorithm here for stronger AI\r\n    let bestMove = null;\r\n    let bestScore = -Infinity;\r\n\r\n    for (let row = 0; row < 3; row++) {\r\n        for (let col = 0; col < 3; col++) {\r\n            if (state[row][col] === AI) {\r\n                const adjacent = getAdjacentCells(row, col);\r\n                for (const [r, c] of adjacent) {\r\n                    if (!state[r][c]) {\r\n                        const tempState = state.map(arr => arr.slice());\r\n                        tempState[r][c] = AI;\r\n                        tempState[row][col] = null;\r\n                        const score = minimax(tempState, 0, false);\r\n                        if (score > bestScore) {\r\n                            bestScore = score;\r\n                            bestMove = { from: { row, col }, to: { row: r, col: c } };\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return bestMove;\r\n}\r\n\r\nfunction minimax(state, depth, isMaximizing) {\r\n    const winner = checkWinner(state);\r\n    if (winner === AI) return 10 - depth;\r\n    if (winner === PLAYER) return depth - 10;\r\n    if (isBoardFull(state)) return 0;\r\n\r\n    let bestScore = isMaximizing ? -Infinity : Infinity;\r\n    for (let row = 0; row < 3; row++) {\r\n        for (let col = 0; col < 3; col++) {\r\n            if (!state[row][col]) {\r\n                state[row][col] = isMaximizing ? AI : PLAYER;\r\n                const score = minimax(state, depth + 1, !isMaximizing);\r\n                state[row][col] = null;\r\n                bestScore = isMaximizing\r\n                    ? Math.max(score, bestScore)\r\n                    : Math.min(score, bestScore);\r\n            }\r\n        }\r\n    }\r\n    return bestScore;\r\n}\r\nfunction isBoardFull(state) {\r\n    return state.every(row => row.every(cell => cell));\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}