{"ast":null,"code":"const PLAYER = 'X';\nconst AI = 'O';\nexport function getBestMove(state, player) {\n  for (let row = 0; row < 3; row++) {\n    for (let col = 0; col < 3; col++) {\n      if (!state[row][col]) {\n        return {\n          row,\n          col\n        };\n      }\n    }\n  }\n  return null;\n}\nexport function getBestMoveToMove(state, player) {\n  // Implementing Minimax algorithm here for stronger AI\n  let bestMove = null;\n  let bestScore = -Infinity;\n  for (let row = 0; row < 3; row++) {\n    for (let col = 0; col < 3; col++) {\n      if (state[row][col] === AI) {\n        const adjacent = getAdjacentCells(row, col);\n        for (const [r, c] of adjacent) {\n          if (!state[r][c]) {\n            const tempState = state.map(arr => arr.slice());\n            tempState[r][c] = AI;\n            tempState[row][col] = null;\n            const score = minimax(tempState, 0, false);\n            if (score > bestScore) {\n              bestScore = score;\n              bestMove = {\n                from: {\n                  row,\n                  col\n                },\n                to: {\n                  row: r,\n                  col: c\n                }\n              };\n            }\n          }\n        }\n      }\n    }\n  }\n  return bestMove;\n}\nfunction minimax(state, depth, isMaximizing) {\n  const winner = checkWinner(state);\n  if (winner === AI) return 10 - depth;\n  if (winner === PLAYER) return depth - 10;\n  if (isBoardFull(state)) return 0;\n  let bestScore = isMaximizing ? -Infinity : Infinity;\n  for (let row = 0; row < 3; row++) {\n    for (let col = 0; col < 3; col++) {\n      if (!state[row][col]) {\n        state[row][col] = isMaximizing ? AI : PLAYER;\n        const score = minimax(state, depth + 1, !isMaximizing);\n        state[row][col] = null;\n        bestScore = isMaximizing ? Math.max(score, bestScore) : Math.min(score, bestScore);\n      }\n    }\n  }\n  return bestScore;\n}\nfunction isBoardFull(state) {\n  return state.every(row => row.every(cell => cell));\n}\nfunction getAdjacentCells(row, col) {\n  let directions = [[-1, 0], [1, 0], [0, -1], [0, 1] // Cardinal directions\n  ];\n\n  // Map directions to new positions\n  directions = directions.map(([dr, dc]) => [row + dr, col + dc]);\n  if (row === 0 && col === 0 || row === 0 && col === 2 || row === 2 && col === 0 || row === 2 && col === 2) {\n    directions = directions.concat([[1, 1]]);\n  }\n  if (row === 1 && col === 1) {\n    directions = directions.concat([[0, 0], [0, 2], [2, 0], [2, 2]]);\n  }\n\n  // Filter positions to stay within a 3x3 grid\n  return directions.filter(([r, c]) => r >= 0 && r < 3 && c >= 0 && c < 3);\n}\nconst checkWinner = state => {\n  const lines = [[[0, 0], [0, 1], [0, 2]], [[1, 0], [1, 1], [1, 2]], [[2, 0], [2, 1], [2, 2]], [[0, 0], [1, 0], [2, 0]], [[0, 1], [1, 1], [2, 1]], [[0, 2], [1, 2], [2, 2]], [[0, 0], [1, 1], [2, 2]], [[0, 2], [1, 1], [2, 0]]];\n  for (const line of lines) {\n    const [a, b, c] = line;\n    if (state[a[0]][a[1]] && state[a[0]][a[1]] === state[b[0]][b[1]] && state[a[0]][a[1]] === state[c[0]][c[1]]) {\n      return state[a[0]][a[1]];\n    }\n  }\n  return null;\n};","map":{"version":3,"names":["PLAYER","AI","getBestMove","state","player","row","col","getBestMoveToMove","bestMove","bestScore","Infinity","adjacent","getAdjacentCells","r","c","tempState","map","arr","slice","score","minimax","from","to","depth","isMaximizing","winner","checkWinner","isBoardFull","Math","max","min","every","cell","directions","dr","dc","concat","filter","lines","line","a","b"],"sources":["E:/Games/CrossMove/frontend - Copy/src/components/checking.js"],"sourcesContent":["const PLAYER = 'X';\r\nconst AI = 'O';\r\n\r\nexport function getBestMove(state, player) {\r\n    for (let row = 0; row < 3; row++) {\r\n        for (let col = 0; col < 3; col++) {\r\n            if (!state[row][col]) {\r\n                return { row, col };\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\nexport function getBestMoveToMove(state, player) {\r\n    // Implementing Minimax algorithm here for stronger AI\r\n    let bestMove = null;\r\n    let bestScore = -Infinity;\r\n\r\n    for (let row = 0; row < 3; row++) {\r\n        for (let col = 0; col < 3; col++) {\r\n            if (state[row][col] === AI) {\r\n                const adjacent = getAdjacentCells(row, col);\r\n                for (const [r, c] of adjacent) {\r\n                    if (!state[r][c]) {\r\n                        const tempState = state.map(arr => arr.slice());\r\n                        tempState[r][c] = AI;\r\n                        tempState[row][col] = null;\r\n                        const score = minimax(tempState, 0, false);\r\n                        if (score > bestScore) {\r\n                            bestScore = score;\r\n                            bestMove = { from: { row, col }, to: { row: r, col: c } };\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return bestMove;\r\n}\r\n\r\nfunction minimax(state, depth, isMaximizing) {\r\n    const winner = checkWinner(state);\r\n    if (winner === AI) return 10 - depth;\r\n    if (winner === PLAYER) return depth - 10;\r\n    if (isBoardFull(state)) return 0;\r\n\r\n    let bestScore = isMaximizing ? -Infinity : Infinity;\r\n    for (let row = 0; row < 3; row++) {\r\n        for (let col = 0; col < 3; col++) {\r\n            if (!state[row][col]) {\r\n                state[row][col] = isMaximizing ? AI : PLAYER;\r\n                const score = minimax(state, depth + 1, !isMaximizing);\r\n                state[row][col] = null;\r\n                bestScore = isMaximizing\r\n                    ? Math.max(score, bestScore)\r\n                    : Math.min(score, bestScore);\r\n            }\r\n        }\r\n    }\r\n    return bestScore;\r\n}\r\nfunction isBoardFull(state) {\r\n    return state.every(row => row.every(cell => cell));\r\n}\r\n\r\nfunction getAdjacentCells(row, col) {\r\n    let directions = [\r\n        [-1, 0], [1, 0], [0, -1], [0, 1], // Cardinal directions\r\n    ];\r\n\r\n    // Map directions to new positions\r\n    directions = directions.map(([dr, dc]) => [row + dr, col + dc]);\r\n    if(row === 0 && col === 0 || row === 0 && col === 2 || row === 2 && col === 0 || row === 2 && col === 2){\r\n        directions = directions.concat([\r\n        [1, 1],\r\n    ]);\r\n    }\r\n\r\n    if(row === 1 && col === 1){\r\n        directions = directions.concat([\r\n        [0, 0], [0, 2], [2, 0], [2, 2]\r\n    ]);\r\n    }\r\n\r\n    // Filter positions to stay within a 3x3 grid\r\n    return directions.filter(([r, c]) => r >= 0 && r < 3 && c >= 0 && c < 3);\r\n}\r\n\r\nconst checkWinner = (state) => {\r\n    const lines = [\r\n      [[0, 0], [0, 1], [0, 2]],\r\n      [[1, 0], [1, 1], [1, 2]],\r\n      [[2, 0], [2, 1], [2, 2]],\r\n      [[0, 0], [1, 0], [2, 0]],\r\n      [[0, 1], [1, 1], [2, 1]],\r\n      [[0, 2], [1, 2], [2, 2]],\r\n      [[0, 0], [1, 1], [2, 2]],\r\n      [[0, 2], [1, 1], [2, 0]]\r\n    ];\r\n\r\n    for (const line of lines) {\r\n      const [a, b, c] = line;\r\n      if (state[a[0]][a[1]] && state[a[0]][a[1]] === state[b[0]][b[1]] && state[a[0]][a[1]] === state[c[0]][c[1]]) {\r\n        return state[a[0]][a[1]];\r\n      }\r\n    }\r\n    return null;\r\n  };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}