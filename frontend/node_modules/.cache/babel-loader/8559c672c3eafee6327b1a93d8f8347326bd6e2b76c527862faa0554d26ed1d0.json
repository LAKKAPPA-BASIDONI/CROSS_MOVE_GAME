{"ast":null,"code":"const PLAYER = 'X';\nconst AI = 'O';\nexport function getBestMove(state, player) {\n  for (let row = 0; row < 3; row++) {\n    for (let col = 0; col < 3; col++) {\n      if (!state[row][col]) {\n        return {\n          row,\n          col\n        };\n      }\n    }\n  }\n  return null;\n}\nexport function getBestMoveToMove(state, player) {\n  // Implementing Minimax algorithm here for stronger AI\n  let bestMove = null;\n  let bestScore = -Infinity;\n  for (let row = 0; row < 3; row++) {\n    for (let col = 0; col < 3; col++) {\n      if (state[row][col] === AI) {\n        const adjacent = getAdjacentCells(row, col);\n        for (const [r, c] of adjacent) {\n          if (!state[r][c]) {\n            const tempState = state.map(arr => arr.slice());\n            tempState[r][c] = AI;\n            tempState[row][col] = null;\n            const score = minimax(tempState, 0, false);\n            if (score > bestScore) {\n              bestScore = score;\n              bestMove = {\n                from: {\n                  row,\n                  col\n                },\n                to: {\n                  row: r,\n                  col: c\n                }\n              };\n            }\n          }\n        }\n      }\n    }\n  }\n  return bestMove;\n}\nfunction minimax(state, depth, isMaximizing) {\n  const winner = checkWinner(state);\n  if (winner === AI) return 10 - depth;\n  if (winner === PLAYER) return depth - 10;\n  if (isBoardFull(state)) return 0;\n  let bestScore = isMaximizing ? -Infinity : Infinity;\n  for (let row = 0; row < 3; row++) {\n    for (let col = 0; col < 3; col++) {\n      if (!state[row][col]) {\n        state[row][col] = isMaximizing ? AI : PLAYER;\n        const score = minimax(state, depth + 1, !isMaximizing);\n        state[row][col] = null;\n        bestScore = isMaximizing ? Math.max(score, bestScore) : Math.min(score, bestScore);\n      }\n    }\n  }\n  return bestScore;\n}\nfunction isBoardFull(state) {\n  return state.every(row => row.every(cell => cell));\n}","map":{"version":3,"names":["PLAYER","AI","getBestMove","state","player","row","col","getBestMoveToMove","bestMove","bestScore","Infinity","adjacent","getAdjacentCells","r","c","tempState","map","arr","slice","score","minimax","from","to","depth","isMaximizing","winner","checkWinner","isBoardFull","Math","max","min","every","cell"],"sources":["E:/Games/CrossMove/frontend - Copy/src/components/checking.js"],"sourcesContent":["const PLAYER = 'X';\r\nconst AI = 'O';\r\n\r\nexport function getBestMove(state, player) {\r\n    for (let row = 0; row < 3; row++) {\r\n        for (let col = 0; col < 3; col++) {\r\n            if (!state[row][col]) {\r\n                return { row, col };\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\nexport function getBestMoveToMove(state, player) {\r\n    // Implementing Minimax algorithm here for stronger AI\r\n    let bestMove = null;\r\n    let bestScore = -Infinity;\r\n\r\n    for (let row = 0; row < 3; row++) {\r\n        for (let col = 0; col < 3; col++) {\r\n            if (state[row][col] === AI) {\r\n                const adjacent = getAdjacentCells(row, col);\r\n                for (const [r, c] of adjacent) {\r\n                    if (!state[r][c]) {\r\n                        const tempState = state.map(arr => arr.slice());\r\n                        tempState[r][c] = AI;\r\n                        tempState[row][col] = null;\r\n                        const score = minimax(tempState, 0, false);\r\n                        if (score > bestScore) {\r\n                            bestScore = score;\r\n                            bestMove = { from: { row, col }, to: { row: r, col: c } };\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return bestMove;\r\n}\r\n\r\nfunction minimax(state, depth, isMaximizing) {\r\n    const winner = checkWinner(state);\r\n    if (winner === AI) return 10 - depth;\r\n    if (winner === PLAYER) return depth - 10;\r\n    if (isBoardFull(state)) return 0;\r\n\r\n    let bestScore = isMaximizing ? -Infinity : Infinity;\r\n    for (let row = 0; row < 3; row++) {\r\n        for (let col = 0; col < 3; col++) {\r\n            if (!state[row][col]) {\r\n                state[row][col] = isMaximizing ? AI : PLAYER;\r\n                const score = minimax(state, depth + 1, !isMaximizing);\r\n                state[row][col] = null;\r\n                bestScore = isMaximizing\r\n                    ? Math.max(score, bestScore)\r\n                    : Math.min(score, bestScore);\r\n            }\r\n        }\r\n    }\r\n    return bestScore;\r\n}\r\nfunction isBoardFull(state) {\r\n    return state.every(row => row.every(cell => cell));\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}